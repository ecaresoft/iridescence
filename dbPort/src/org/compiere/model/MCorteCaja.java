/* Created on 13-mar-2005 */package org.compiere.model;import java.math.BigDecimal;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;import java.util.Properties;import java.util.logging.Level;import org.adempiere.exceptions.MedsysException;import org.compiere.util.CLogger;import org.compiere.util.DB;/** * <b>Fecha:</b> 07/Marzo/2005 * <p> * <b>Modificado: </b> $Author: taniap $ * <p> * <b>En :</b> $Date: 2005/11/15 19:27:42 $ * <p> *  * @author hassan reyes * @version $Revision: 1.4 $ */public class MCorteCaja extends X_EXME_CorteCaja {	public static class MCashLineDiff extends MCashLine {		private static final long	serialVersionUID	= 1L;		private BigDecimal			totalSystemAmt;		private BigDecimal			totalBalanceAmt;		public MCashLineDiff(MCorteCaja corte, int formaPagoId) {			super(corte.getCtx(), 0, corte.get_TrxName());			setClientOrg(corte);			setC_Cash_ID(corte.getC_Cash_ID());			setEXME_FormaPago_ID(formaPagoId);		}		public void setAmounts(BigDecimal totalSystemAmt, BigDecimal totalBalanceAmt) {			setTotalSystemAmt(totalSystemAmt);			setTotalBalanceAmt(totalBalanceAmt);			setAmount(totalBalanceAmt.subtract(totalSystemAmt));		}		public BigDecimal getTotalSystemAmt() {			return totalSystemAmt;		}		private void setTotalSystemAmt(BigDecimal totalSystemAmt) {			this.totalSystemAmt = totalSystemAmt == null ? BigDecimal.ZERO : totalSystemAmt;		}		public BigDecimal getTotalBalanceAmt() {			return totalBalanceAmt;		}		private void setTotalBalanceAmt(BigDecimal totalBalanceAmt) {			this.totalBalanceAmt = totalBalanceAmt == null ? BigDecimal.ZERO : totalBalanceAmt;		}	}	private static final long	serialVersionUID	= 1L;	/** Static Logger */	private static CLogger		s_log				= CLogger.getCLogger(MCorteCaja.class);	/**	 * @param ctx	 * @param ID	 * @param trxName	 */	public MCorteCaja(Properties ctx, int ID, String trxName) {		super(ctx, ID, trxName);	}	/**	 * @param ctx	 * @param rs	 * @param trxName	 */	public MCorteCaja(Properties ctx, ResultSet rs, String trxName) {		super(ctx, rs, trxName);	}	/**	 * Obtenemos la informacion del Corte de Caja	 * 	 * @param ctx	 * @param id cash	 * @param trxName	 * @return	 * @throws Exception	 */	public static MCorteCaja get(Properties ctx, int c_Cash_ID, String trxName) throws Exception {		s_log.config("MCorteCaja#get");		// String sql = " SELECT * FROM EXME_CorteCaja " + " WHERE IsActive='Y' AND C_Cash_ID = ? ";		// sql = MEXMELookupInfo.addAccessLevelSQL(ctx, sql.toString(), "EXME_CorteCaja");		return new Query(ctx, Table_Name, " C_Cash_ID=? ", trxName)//			.setParameters(c_Cash_ID)//			.setOnlyActiveRecords(true)//			.addAccessLevelSQL(true)//			.first();	}	public int getId() {		return getEXME_CorteCaja_ID();	}	/**	 * Diferencias por forma de pago	 * 	 * @param corteDet el objeto MCorteCajaDet	 * 	 * @return true si hay diferencias en caja, false si no las hay.	 * @throws MedsysException una excepcion para manejar el error en el metodo llamador si ocurriese.	 * @author jcantu Modificado por Jesus Cantu el 10 de mayo del 2012.	 */	public boolean getDiferencias(MCorteCajaDet corteDet) throws MedsysException {		StringBuilder sql = new StringBuilder();		sql.append(" Select  NVL( SUM(cl.AMOUNT),0) as sumAmt from C_CashLine cl where cl.isActive = 'Y' ");		sql.append(" and cl.C_Cash_ID = ? and cl.EXME_FormaPago_ID = ? ");		// Condicion a√±adida para evitar que los registros tipo ajuste sean tomados en cuenta en el total para Count Cash (WCorteCaja)		// RQM 4429 - Count Cash. Manda mensaje de diferencias cuando no las hay, ya que esta tomando montos de ajustes realizados desde LATE CHARGES		// Mayo 15 de 2013		sql.append(" AND NOT EXISTS(SELECT C_PAYMENT_ID FROM C_PAYMENT P INNER JOIN C_CHARGE CH ON CH.C_CHARGE_ID = P.C_CHARGE_ID ").append(			" WHERE C_PAYMENT_ID = CL.C_PAYMENT_ID AND CH.TYPE IN ('A', 'B', 'G', 'C', 'D', 'I')) ");		// RQM 2314: Diferencia en corte de Caja. Estaba pasandole el SQL en el segundo parametro		// Duplicaba el query y ocurria error, no manejaba error y siempre devolvia true.		sql.append(MEXMELookupInfo.addAccessLevelSQL(getCtx(), " ", X_C_CashLine.Table_Name, "cl"));		BigDecimal grandTotal = DB.getSQLValueBD(get_TrxName(), sql.toString(), getC_Cash_ID(), corteDet.getEXME_FormaPago_ID());		return corteDet.getAmount().compareTo(grandTotal) != 0;	}	/**	 * Diferencias por forma de pago	 * 	 * @param corteDet	 * @return	 */	public BigDecimal getSumAmount() {		StringBuilder sql = new StringBuilder();		sql.append(" SELECT     NVL( SUM(ccd.CashierAmount),0) AS sumAmt ");		sql.append(" FROM       EXME_CorteCaja cc ");		sql.append(" INNER JOIN EXME_CorteCajaDet ccd ON cc.EXME_CorteCaja_ID = ccd.EXME_CorteCaja_ID ");		sql.append(" WHERE      cc.isActive = 'Y' ");		sql.append(MEXMELookupInfo.addAccessLevelSQL(getCtx(), " ", "EXME_CorteCaja", "cc"));		sql.append(" AND        cc.EXME_CorteCaja_ID = ? ");		return DB.getSQLValueBD(get_TrxName(), sql.toString(), getEXME_CorteCaja_ID());	}		/**	 * @return Formas de Pago que no coninciden en la conciliacion de caja	 */	public List<MCashLineDiff> getConciliacion() {		final List<MCashLineDiff> lista = new ArrayList<MCashLineDiff>();		try {			s_log.log(Level.INFO, "Conciliacion... Corte de Caja >> " + getEXME_CorteCaja_ID());			// traigo las formas de pago del corte de caja			final List<MCorteCajaDet> lineFormaCorte = MCorteCajaDet.getLstLineas(getCtx(), getEXME_CorteCaja_ID(), get_TrxName());			final List<MFormaPago> lstFormas;			if (MCountry.isMexico(getCtx())) {				lstFormas = MCorteCajaDet.getListFormasPago(new MCash(getCtx(), getC_Cash_ID(), get_TrxName()));			} else {				lstFormas = MCorteCajaDet.getListFormasPago(getCtx(), getC_Cash_ID(), true, get_TrxName());			}			// traigo las formas de pago del cash			for (MFormaPago cashF : lstFormas) {				boolean added = false;				// ir por montos -- igualamos las cantidades a dos decimales.				// Card #1384, se quitan los absolutos				final BigDecimal cashlineAmount =					MFormaPago.getAmountCashLine(getCtx(), getC_Cash_ID(), cashF.getEXME_FormaPago_ID(), get_TrxName());//.abs()				// barro la lista de corte de caja detalle				for (MCorteCajaDet corteF : lineFormaCorte) {					s_log.log(Level.INFO, "Formas de pago >" + cashF.getEXME_FormaPago_ID() + " > " + corteF.getEXME_FormaPago_ID());					// comparo formas de pago					if (cashF.getEXME_FormaPago_ID() == corteF.getEXME_FormaPago_ID()) {						added = true;						// ir por montos -- igualamos las cantidades a dos decimales.						// Card #1384, se quitan los absolutos						final BigDecimal corteAmount = corteF.getAmount().setScale(2, BigDecimal.ROUND_HALF_UP);//.abs()						s_log.log(Level.INFO, "Montos >" + cashlineAmount + " > " + corteAmount);						// comparo montos ya que las formas de pago son iguales						if (cashlineAmount.compareTo(corteAmount) != 0) {							final MCashLineDiff linea = new MCashLineDiff(this, cashF.getEXME_FormaPago_ID());							s_log.log(Level.INFO, "linea EXME_CorteCajaDet_ID >" + corteF.getEXME_CorteCajaDet_ID());							s_log.log(Level.INFO, "linea EXME_FormaPago_ID > " + cashF.getEXME_FormaPago_ID());							linea.setAmounts(cashlineAmount, corteAmount);							lista.add(linea);						}					}				}				// si la diferencia es != 0 .- Lama				if (!added && cashlineAmount.compareTo(BigDecimal.ZERO) != 0) {					final MCashLineDiff linea2 = new MCashLineDiff(this, cashF.getEXME_FormaPago_ID());					s_log.log(Level.INFO, "linea2 EXME_FormaPago_ID > " + cashF.getEXME_FormaPago_ID());					linea2.setAmounts(cashlineAmount, BigDecimal.ZERO);					lista.add(linea2);				}			}		} catch (Exception e) {			s_log.log(Level.SEVERE, e.toString(), e);		}		return lista;	}}